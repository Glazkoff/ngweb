# Nginx

- Создали в корне папку nginx-conf
- Перешли внутрь папки nginx-conf и создали файл nginx.conf

## nginx.conf - серверный блок

Наш серверный блок содержит следующую информацию:

## Директивы:

- `listen`: данный элемент просит Nginx прослушивать порт 80, что позволит нам использовать плагин webroot Certbot для наших запросов сертификатов. Обратите внимание, что мы пока не будем включать порт 443, мы обновим нашу конфигурацию и добавим SSL после успешного получения наших сертификатов.
- `server_name`: этот элемент определяет имя вашего сервера и серверный блок, которые должны использоваться для запросов к вашему серверу. Обязательно замените example.com в этой строке на ваше собственное доменное имя.
- `index`: директива index определяет файлы, которые будут использоваться в качестве индексов при обработке запросов к вашему серверу. Здесь мы изменили порядок приоритета по умолчанию, поставив index.php перед index.html, в результате чего Nginx будет давать приоритет файлам с именем index.php при наличии возможности.
- `root`: наша директива root назначает имя корневой директории для запросов к нашему серверу. Эта директория, /var/www/html, создается в качестве точки монтирования в момент сборки с помощью инструкций в Dockerfile WordPress. Эти инструкции Dockerfile также гарантируют, что файлы релиза WordPress монтируются в этот том.


## Блоки расположения:

- `location ~ /.well-known/acme-challenge`: этот блок расположения будет обрабатывать запросы в директории .well-known, где Certbot будет размещать временный файл для подтверждения того, что DNS для нашего домена будет работать с нашим сервером. Настроив данную конфигурацию, мы сможем использовать плагин webroot Certbot для получения сертификатов для нашего домена.
location /: в этом блоке расположения мы будем использовать директиву try_files для проверки файлов, соответствующих отдельным запросам URI. Вместо того, чтобы возвращать по умолчанию статус 404 не найдено, мы будем передавать контроль файлу index.php Wordpress с аргументами запроса.
- `location ~\.php$`: этот блок расположения будет обрабатывать PHP-запросы и проксировать эти запросы в наш контейнер wordpress. Поскольку наш образ WordPress Docker будет опираться на образ php:fpm, мы также добавим параметры конфигурации, принадлежащие протоколу FastCGI, в этот блок. Nginx требует наличия независимого процессора PHP для запросов PHP: в нашем случае эти запросы будут обрабатываться процессором php-fpm, который будет включать образ php:fpm. Кроме того, этот блок расположения содержит директивы FastCGI, переменные и опции, которые будут проксировать запросы для приложения WordPress, запущенного в нашем контейнере wordpress, задавать предпочитаемый индекс захваченного URI запроса, а также выполнять парсинг URI-запросов.
- `location ~ /\.ht`: этот блок будет обрабатывать файлы .htaccess, поскольку Nginx не будет обслуживать их. Директива deny_all гарантирует, что файлы .htaccess никогда не будут отображаться для пользователей.
- `location = /favicon.ico, location = /robots.txt`: эти блоки гарантируют, что запросы для /favicon.ico и /robots.txt не будут регистрироваться.
- `location ~*\ (css|gif|ico|jpeg|jpg|js|png)$`: этот блок отключает запись в журнал для запросов статичных активов и гарантирует, что эти активы будут иметь высокую кэшируемость, поскольку обычно их трудно обслуживать.




# .env

Переменные в файле
`MYSQL_ROOT_PASSWORD=your_root_password` - пароль root пользователя
`MYSQL_USER=your_wordpress_database_user` - логин пользователя БД для wordpress
`MYSQL_PASSWORD=your_wordpress_database_password` - пароль БД для wordpress

# Docker

## Что нужно перед началом работы?
- Включить виртуализацию на рабочем устройстве (Hyper-V)
- Скачать и установить [Docker Desktop](https://www.docker.com/products/docker-desktop)
- Проверить что всё хорошо установилось
  - `docker -v`
  - `docker-compose -v`
- Установить расширение в VSCode `Docker` от Microsoft

wsl.exe -l -v
wsl.exe --set-version Ubuntu 2
wsl.exe --set-default-version 2
https://docs.microsoft.com/ru-ru/windows/wsl/install-win10

## CLI
```
docker run -d -p 80:80 *название образа*
```

- `-d` — запуск контейнера в отключенном режиме (в фоновом окне)
- `-p 80:80` — сопоставление порта 80 узла с портом 80 в контейнере.
- `*название образа*` — используемый образ.

```
docker-compose up -d
```

Создаём контейнеры с помощью команды docker-compose up и флага -d, которые будут запускать контейнеры db​​​, wordpress и webserver в фоновом режиме


## Docker Compose 

### Служба db
Определение службы db включает следующие параметры:

- `image`: данный элемент указывает Compose, какой образ будет загружаться для создания контейнера. Мы закрепим здесь образ mysql:8.0, чтобы избежать будущих конфликтов, так как образ mysql:latest продолжит обновляться. Дополнительную информацию о закреплении версии и предотвращении конфликтов зависимостей см. в документации Docker в разделе Рекомендации по работе с Dockerfile.
- `container_name`: данный элемент указывает имя контейнера.
- `restart`: данный параметр определяет политику перезапуска контейнера. По умолчанию установлено значение no, но мы задали значение, согласно которому контейнер будет перезапускаться, пока не будет остановлен вручную.
- `env_file`: этот параметр указывает Compose, что мы хотим добавить переменные среды из файла с именем .env, расположенного в контексте сборки. В этом случае в качестве контекста сборки используется наша текущая директория.
- `environment`: этот параметр позволяет добавить дополнительные переменные среды, не определенные в файле .env. Мы настроим переменную MYSQL_DATABASE со значением wordpress, которая будет предоставлять имя нашей базы данных приложения. Поскольку эта информация не является чувствительной, мы можем включить ее напрямую в файл docker-compose.yml.
- `volumes`: здесь мы монтируем именованный том с названием dbdata в директорию /var/lib/mysql в контейнере. Это стандартная директория данных в большинстве дистрибутивов.
- `command`: данный параметр указывает команду, которая будет переопределять используемое по умолчанию значение инструкции CMD для образа. В нашем случае мы добавим параметр для стандартной команды mysqld образа Docker, которая запускает сервер MySQL в контейнере. Эта опция --default-authentication-plugin=mysql_native_password устанавливает для системной переменной --default-authentication-plugin значение mysql_native_password, которое указывает, какой механизм аутентификации должен управлять новыми запросами аутентификации для сервера. Поскольку PHP и наш образ WordPress не будут поддерживать новое значение аутентификации MySQL по умолчанию, мы должны внести изменения, чтобы выполнить аутентификацию пользователя базы данных приложения.
- `networks`: данный параметр указывает, что служба приложения будет подключаться к сети app-network, которую мы определим внизу файла.

### Служба wordpress
- `depends_on`: этот параметр гарантирует, что наши контейнеры будут запускаться в порядке зависимости, и контейнер wordpress запускается после контейнера db. Наше приложение WordPress зависит от наличия базы данных приложения и пользователя, поэтому установка такого порядка зависимостей позволит выполнять запуск приложения корректно.
- `image`: для этой настройки мы будем использовать образ Wordpress 5.11-fpm-alpine. Как было показано в шаге 1, использование этого образа гарантирует, что наше приложение будет иметь процессор php-fpm, который требуется Nginx для обработки PHP. Это еще и образ alpine, полученный из проекта Alpine Linux, который поможет снизить общий размер образа. Дополнительную информацию о преимуществах и недостатках использования образов alpine, а также о том, имеет ли это смысл в случае вашего приложения, см. в полном описании в разделе Варианты образа на странице образа WordPress на Docker Hub.
- `env_file`: и снова мы укажем, что хотим загрузить значения из файла .env, поскольку там мы определили пользователя базы данных приложения и пароль.
environment: здесь мы будем использовать значения, определенные в файле .env, но мы привяжем их к именам переменных, которые требуются для образа WordPress: WORDPRESS_DB_USER и WORDPRESS_DB_PASSWORD. Также мы определяем значение WORDPRESS_DB_HOST, которое будет указывать сервер MySQL, который будет работать в контейнере db, доступный на используемом по умолчанию порту MySQL 3306. Наше значение WORDPRESS_DB_NAME будет тем же, которое мы указали при определении службы MySQL для MYSQL_DATABASE: wordpress.
- `volumes`: мы монтируем том с именем wordpress на точку монтирования /var/www/html, созданную образом WordPress. Использование тома с именем таким образом позволит разделить наш код приложения с другими контейнерами.
- `networks`: мы добавляем контейнер wordpress в сеть app-network.

### Сервис webserver

- `ports`: этот параметр открывает порт 80, чтобы активировать параметры конфигурации, определенные нами в файле nginx.conf в шаге 1.
- `volumes`: здесь мы определяем комбинацию названных томов и связанных монтируемых образов:
  - `wordpress:/var/www/html`: этот параметр будет монтировать код нашего приложения WordPress в директорию /var/www/html, директорию, которую мы задали в качестве root-директории в нашем серверном блоке Nginx.
  - `./nginx-conf:/etc/nginx/conf.d`: этот элемент будет монтировать директорию конфигурации Nginx на хост в соответствующую директорию в контейнере, гарантируя, что любые изменения, которые мы вносим в файлы на хосте, будут отражены в контейнере.
  - `certbot-etc:/etc/letsencrypt`: этот элемент будет монтировать соответствующие сертификаты и ключи Let’s Encrypt для нашего домена в соответствующую директорию контейнера.
- Здесь мы снова добавили этот контейнер в сеть app-network.

### Сервис certbot

Это определение попросит Compose извлекать образ certbot/certbot из Docker Hub. Также оно использует имена томов для обмена ресурсами с контейнером Nginx, включая доменные сертификаты и ключ в certbot-etc и код приложения в wordpress.

Мы использовали depends_on, чтобы указать, что контейнер certbot следует запускать только после запуска службы webserver.

Также мы включили параметр command, указывающий субкоманду для запуска с используемой контейнером по умолчанию командой certbot. Субкоманда certonly будет получать сертификат со следующими параметрами:

--webroot: данный элемент говорит Certbot о необходимости использования плагина webroot для размещения файлов в папке webroot для аутентификации. Работа плагина основана на методе валидации HTTP-01, который использует запрос HTTP, чтобы доказать, что Certbot может получить доступ к ресурсам с сервера, который отвечает на заданное доменное имя.
--webroot-path: данный элемент указывает путь директории webroot.
--email: предпочитаемый адрес электронной почты для регистрации и восстановления.
--agree-tos: данный элемент указывает, что вы принимаете Соглашение о подписке ACME.
--no-eff-email: данный элемент указывает Certbot, что вы не хотите делиться адресом электронной почты с Electronic Frontier Foundation​​​ (EFF). Вы можете пропустить этот элемент.
--staging: данный элемент говорит Certbot, что вы хотите использовать промежуточную среду Let’s Encrypt для получения тестовых сертификатов. При использовании этого параметра вы можете протестировать параметры конфигурации и избежать возможных пределов для запросов домена. Дополнительную информацию об этих предельных значениях см. в документации по ограничениям скорости Let’s Encrypt.
-d: данный элемент позволяет указать доменные имена, которые вы хотите использовать для вашего запроса. В нашем случае мы включили example.com и www.example.com. Обязательно замените эти данные на имя вашего домена

---

So i found the solution. I did this...

1. docker-compose down
2. Deleted old volumes (if there is no significant data) docker system prune --force --volumes
3. Added command: --disable-partition-engine-check to mysql section in docker-compose.yml
4. Ran it with docker-compose up -d to set it up in background.